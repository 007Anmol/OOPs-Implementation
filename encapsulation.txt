ðŸ”¹ OOPs â€“ Encapsulation (Basic â†’ Advanced)

With C++ Implementations

1ï¸âƒ£ What is Encapsulation? (Beginner Level)
ðŸ“Œ Definition

Encapsulation means:

Wrapping data (variables) and methods (functions) together into a single unit (class) and restricting direct access to the data.

In simple words:

Data is hidden

Access is controlled

ðŸ’¡ Real-Life Example

ðŸ’³ ATM Machine

You cannot directly access bank balance

You interact via:

withdraw()

deposit()

checkBalance()

ðŸ‘‰ Balance is encapsulated inside the bank system.

2ï¸âƒ£ Why Do We Need Encapsulation?
Benefit	Explanation
Data Security	Prevents unauthorized access
Control	Validate before modifying data
Maintainability	Internal change doesnâ€™t affect external code
Modularity	Cleaner, organized code
3ï¸âƒ£ Encapsulation in C++ â€“ Core Concept

Encapsulation is implemented using:

Access Specifiers

private

protected

public

ðŸ”‘ Rule of Thumb

Data members â†’ private
Access via public methods

4ï¸âƒ£ Basic Encapsulation Example
âŒ Without Encapsulation (Bad Practice)
class Student {
public:
    int marks;
};

Student s;
s.marks = -100;  // Invalid but allowed


âŒ No control, no validation.

âœ… With Encapsulation (Correct Way)
class Student {
private:
    int marks;

public:
    void setMarks(int m) {
        if (m >= 0 && m <= 100)
            marks = m;
        else
            cout << "Invalid marks\n";
    }

    int getMarks() {
        return marks;
    }
};

int main() {
    Student s;
    s.setMarks(95);
    cout << s.getMarks();
}

ðŸ” Key Points

marks is hidden

Validation is enforced

External code cannot corrupt data

5ï¸âƒ£ Getter & Setter Pattern (Very Important)
ðŸ“Œ Standard Encapsulation Pattern
class Employee {
private:
    int salary;

public:
    void setSalary(int s) {
        if (s > 0)
            salary = s;
    }

    int getSalary() {
        return salary;
    }
};


ðŸ”¹ Used heavily in:

Enterprise software

APIs

Backend systems

6ï¸âƒ£ Encapsulation â‰  Data Hiding (Interview Trap)
â“ Are they the same?

âŒ No

Term	Meaning
Data Hiding	Restricting access (using private)
Encapsulation	Binding data + methods together

Encapsulation uses data hiding, but is broader.

7ï¸âƒ£ Encapsulation with Business Logic

Encapsulation is not just getters/setters.

class BankAccount {
private:
    double balance;

public:
    BankAccount(double bal) {
        if (bal >= 0)
            balance = bal;
        else
            balance = 0;
    }

    void deposit(double amount) {
        if (amount > 0)
            balance += amount;
    }

    void withdraw(double amount) {
        if (amount <= balance)
            balance -= amount;
        else
            cout << "Insufficient Balance\n";
    }

    double getBalance() {
        return balance;
    }
};

ðŸ”¥ Why This Is Good?

Business rules enforced

No invalid state possible

Balance can never be negative

8ï¸âƒ£ Encapsulation + const Correctness (Advanced)
class User {
private:
    string name;

public:
    User(string n) : name(n) {}

    string getName() const {
        return name;
    }
};

ðŸ”‘ Why Important?

Guarantees function wonâ€™t modify object

Critical in large codebases

9ï¸âƒ£ Encapsulation Using protected (Inheritance Scenario)
class Account {
protected:
    double balance;

public:
    Account(double bal) : balance(bal) {}
};

class SavingsAccount : public Account {
public:
    SavingsAccount(double bal) : Account(bal) {}

    void addInterest() {
        balance += balance * 0.05;
    }
};

ðŸ” Explanation

balance hidden from outside world

Accessible to child class

Controlled extension

ðŸ”Ÿ Encapsulation vs Abstraction (VERY COMMON)
Encapsulation	Abstraction
How data is protected	What details are shown
Uses access specifiers	Uses abstract classes/interfaces
Implementation-level	Design-level

ðŸ‘‰ They work together, not against each other.

1ï¸âƒ£1ï¸âƒ£ Encapsulation & Immutability (Advanced Design)
class ImmutableUser {
private:
    const int id;
    const string name;

public:
    ImmutableUser(int id, string name) : id(id), name(name) {}

    int getId() const { return id; }
    string getName() const { return name; }
};

ðŸ”¥ Benefits

Thread-safe

No accidental modification

Common in functional & concurrent systems

1ï¸âƒ£2ï¸âƒ£ Encapsulation in Real-World Software

Used heavily in:

Banking systems

Payment gateways

Microservices

APIs

ORM models

Example:

user.updatePassword(oldPwd, newPwd);


You never directly access:

user.password = "123";

1ï¸âƒ£3ï¸âƒ£ Common Interview Questions
â“ Can encapsulation exist without abstraction?

âœ… Yes.

â“ Can encapsulation be achieved without classes?

âŒ No (in OOP).

â“ Is encapsulation only getters/setters?

âŒ No. Itâ€™s about controlled access + logic.

â“ Why make data members private?

âœ” Prevent invalid states
âœ” Enforce rules
âœ” Reduce bugs

ðŸš¨ Common Mistakes (Avoid These)

âŒ Making everything public
âŒ Getters/setters without validation
âŒ Exposing internal objects directly

Bad:

vector<int>& getMarks() { return marks; }


Good:

vector<int> getMarks() { return marks; }

ðŸŽ¯ Final Takeaway

Encapsulation protects your system from misuse, bugs, and future changes.

If abstraction is what to show,
encapsulation is how safely you show it.
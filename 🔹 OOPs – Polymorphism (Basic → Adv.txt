ğŸ”¹ OOPs â€“ Polymorphism (Basic â†’ Advanced)

With C++ Implementations

1ï¸âƒ£ What is Polymorphism? (Beginner Level)
ğŸ“Œ Definition

Polymorphism means:

One interface, many forms

In simple terms:

Same function name

Different behavior

Depends on context

ğŸ’¡ Real-Life Example

ğŸ—£ï¸ Word â€œrunâ€

Run a program

Run a race

Run a company

Same word â†’ different meaning â†’ polymorphism

2ï¸âƒ£ Why Polymorphism is Needed?
Benefit	Explanation
Flexibility	Same code works for different objects
Extensibility	Add new types without modifying existing code
Clean Design	Eliminates large if-else chains
Reusability	Common interfaces
3ï¸âƒ£ Types of Polymorphism in C++

C++ supports two major types:

Type	When it happens
Compile-time	During compilation
Run-time	During execution
ğŸ”¹ PART 1: Compile-Time Polymorphism

Achieved using:

Function Overloading

Operator Overloading

Templates (Parametric polymorphism)

4ï¸âƒ£ Function Overloading
ğŸ“Œ Same function name, different parameters
#include <iostream>
using namespace std;

class Math {
public:
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
};

int main() {
    Math m;
    cout << m.add(2, 3) << endl;
    cout << m.add(2.5, 3.5) << endl;
    cout << m.add(1, 2, 3) << endl;
}

ğŸ” Key Points

Decision made at compile time

Return type alone cannot differentiate overloads âŒ

5ï¸âƒ£ Operator Overloading
ğŸ“Œ Making operators work for user-defined types
class Point {
public:
    int x, y;

    Point(int x, int y) : x(x), y(y) {}

    Point operator + (const Point& p) {
        return Point(x + p.x, y + p.y);
    }
};

int main() {
    Point p1(2, 3), p2(4, 5);
    Point p3 = p1 + p2;
    cout << p3.x << " " << p3.y;
}

ğŸ”¥ Interview Insight

Operator overloading improves readability

Should behave intuitively

6ï¸âƒ£ Templates â€“ Parametric Polymorphism
template <typename T>
T maximum(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    cout << maximum(3, 7) << endl;
    cout << maximum(3.5, 2.1) << endl;
}

ğŸ”‘ Why This is Polymorphism?

Same logic â†’ works for multiple data types

ğŸ”¹ PART 2: Run-Time Polymorphism (MOST IMPORTANT)

Achieved using:

Inheritance

Virtual functions

Base class pointer â†’ Derived object

7ï¸âƒ£ Runtime Polymorphism â€“ Core Idea

Function call is resolved at runtime based on object type, not pointer type

8ï¸âƒ£ Basic Runtime Polymorphism Example
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void speak() {
        cout << "Animal makes a sound" << endl;
    }
};

class Dog : public Animal {
public:
    void speak() override {
        cout << "Dog barks" << endl;
    }
};

class Cat : public Animal {
public:
    void speak() override {
        cout << "Cat meows" << endl;
    }
};

int main() {
    Animal* a;

    Dog d;
    Cat c;

    a = &d;
    a->speak();  // Dog barks

    a = &c;
    a->speak();  // Cat meows
}

ğŸ” What Happened?

Pointer type: Animal*

Object type: Dog / Cat

Output depends on object, not pointer

9ï¸âƒ£ Without virtual â€“ Very Common Trap âŒ
class Animal {
public:
    void speak() {
        cout << "Animal sound";
    }
};

Animal* a = new Dog();
a->speak();   // Animal sound âŒ


âŒ No polymorphism without virtual.

ğŸ”Ÿ How Runtime Polymorphism Works Internally (V-Table)
ğŸ§  Behind the Scenes

Compiler creates Virtual Table (vtable)

Each object stores a vptr

At runtime, correct function is picked

Animal*
   |
   ---> vptr ----> Dog::speak()

1ï¸âƒ£1ï¸âƒ£ override Keyword (Best Practice)
void speak() override;

Why Use It?

Compiler error if signature mismatch

Prevents silent bugs

1ï¸âƒ£2ï¸âƒ£ Base Pointer, Derived Object Rule

âœ… Allowed:

Base* b = new Derived();


âŒ Not allowed:

Derived* d = new Base();


Why?

Derived expects more features

1ï¸âƒ£3ï¸âƒ£ Virtual Destructor (ADVANCED & CRITICAL)
class Base {
public:
    virtual ~Base() {
        cout << "Base Destructor\n";
    }
};

class Derived : public Base {
public:
    ~Derived() {
        cout << "Derived Destructor\n";
    }
};

Base* b = new Derived();
delete b;

Output:
Derived Destructor
Base Destructor


Without virtual destructor â†’ memory leak

1ï¸âƒ£4ï¸âƒ£ Pure Virtual Functions & Polymorphism
class Shape {
public:
    virtual double area() = 0;
};

class Rectangle : public Shape {
public:
    double area() {
        return 10 * 5;
    }
};


ğŸ”¹ This is runtime polymorphism + abstraction

1ï¸âƒ£5ï¸âƒ£ Polymorphism vs Overloading (Interview Favorite)
Overloading	Overriding
Compile time	Runtime
Same class	Base + Derived
Different parameters	Same signature
No virtual	Needs virtual
1ï¸âƒ£6ï¸âƒ£ Polymorphism Replacing if-else (Real-World)

âŒ Bad Design:

if(type == "UPI") payUPI();
else if(type == "CARD") payCard();


âœ… Polymorphism:

class Payment {
public:
    virtual void pay() = 0;
};

class UPI : public Payment {
public:
    void pay() { cout << "UPI payment"; }
};

Payment* p = new UPI();
p->pay();

1ï¸âƒ£7ï¸âƒ£ When NOT to Use Polymorphism

âŒ Small utility functions
âŒ Performance-critical inner loops
âŒ No behavior variation

Overuse = complexity

ğŸ”¥ Common Interview Questions
â“ Is polymorphism possible without inheritance?

âœ… Compile-time polymorphism â†’ Yes
âŒ Runtime polymorphism â†’ No

â“ Can constructors be virtual?

âŒ No

â“ Can static functions be virtual?

âŒ No (belongs to class, not object)

â“ What happens if base function is not virtual?

âŒ Compile-time binding

ğŸš¨ Common Mistakes

âŒ Forgetting virtual
âŒ Not using override
âŒ Missing virtual destructor
âŒ Calling derived methods via value (object slicing)

ğŸ¯ Final Takeaway

Polymorphism allows systems to grow without changing existing code.

Compile-time â†’ flexibility

Runtime â†’ extensibility

Core of:

Clean Architecture

Frameworks

Plugins

APIs